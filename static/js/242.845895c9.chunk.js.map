{"version":3,"file":"static/js/242.845895c9.chunk.js","mappings":"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","sources":["../node_modules/@meshconnect/web-link-sdk/node_modules/viem/errors/ccip.ts","../node_modules/@meshconnect/web-link-sdk/node_modules/viem/utils/address/isAddressEqual.ts","../node_modules/@meshconnect/web-link-sdk/node_modules/viem/utils/ccip.ts"],"sourcesContent":["import type { Address } from 'abitype'\n\nimport type { Hex } from '../types/misc.js'\nimport { stringify } from '../utils/stringify.js'\n\nimport { BaseError } from './base.js'\nimport { getUrl } from './utils.js'\n\nexport type OffchainLookupErrorType = OffchainLookupError & {\n  name: 'OffchainLookupError'\n}\nexport class OffchainLookupError extends BaseError {\n  constructor({\n    callbackSelector,\n    cause,\n    data,\n    extraData,\n    sender,\n    urls,\n  }: {\n    callbackSelector: Hex\n    cause: BaseError\n    data: Hex\n    extraData: Hex\n    sender: Address\n    urls: readonly string[]\n  }) {\n    super(\n      cause.shortMessage ||\n        'An error occurred while fetching for an offchain result.',\n      {\n        cause,\n        metaMessages: [\n          ...(cause.metaMessages || []),\n          cause.metaMessages?.length ? '' : [],\n          'Offchain Gateway Call:',\n          urls && [\n            '  Gateway URL(s):',\n            ...urls.map((url) => `    ${getUrl(url)}`),\n          ],\n          `  Sender: ${sender}`,\n          `  Data: ${data}`,\n          `  Callback selector: ${callbackSelector}`,\n          `  Extra data: ${extraData}`,\n        ].flat(),\n        name: 'OffchainLookupError',\n      },\n    )\n  }\n}\n\nexport type OffchainLookupResponseMalformedErrorType =\n  OffchainLookupResponseMalformedError & {\n    name: 'OffchainLookupResponseMalformedError'\n  }\nexport class OffchainLookupResponseMalformedError extends BaseError {\n  constructor({ result, url }: { result: any; url: string }) {\n    super(\n      'Offchain gateway response is malformed. Response data must be a hex value.',\n      {\n        metaMessages: [\n          `Gateway URL: ${getUrl(url)}`,\n          `Response: ${stringify(result)}`,\n        ],\n        name: 'OffchainLookupResponseMalformedError',\n      },\n    )\n  }\n}\n\n/** @internal */\nexport type OffchainLookupSenderMismatchErrorType =\n  OffchainLookupSenderMismatchError & {\n    name: 'OffchainLookupSenderMismatchError'\n  }\nexport class OffchainLookupSenderMismatchError extends BaseError {\n  constructor({ sender, to }: { sender: Address; to: Address }) {\n    super(\n      'Reverted sender address does not match target contract address (`to`).',\n      {\n        metaMessages: [\n          `Contract address: ${to}`,\n          `OffchainLookup sender address: ${sender}`,\n        ],\n        name: 'OffchainLookupSenderMismatchError',\n      },\n    )\n  }\n}\n","import type { Address } from 'abitype'\n\nimport {\n  InvalidAddressError,\n  type InvalidAddressErrorType,\n} from '../../errors/address.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport { isAddress } from './isAddress.js'\n\nexport type IsAddressEqualReturnType = boolean\nexport type IsAddressEqualErrorType = InvalidAddressErrorType | ErrorType\n\nexport function isAddressEqual(a: Address, b: Address) {\n  if (!isAddress(a, { strict: false }))\n    throw new InvalidAddressError({ address: a })\n  if (!isAddress(b, { strict: false }))\n    throw new InvalidAddressError({ address: b })\n  return a.toLowerCase() === b.toLowerCase()\n}\n","import type { Abi, Address } from 'abitype'\n\nimport { type CallParameters, call } from '../actions/public/call.js'\nimport type { Transport } from '../clients/transports/createTransport.js'\nimport type { BaseError } from '../errors/base.js'\nimport {\n  OffchainLookupError,\n  type OffchainLookupErrorType as OffchainLookupErrorType_,\n  OffchainLookupResponseMalformedError,\n  type OffchainLookupResponseMalformedErrorType,\n  OffchainLookupSenderMismatchError,\n} from '../errors/ccip.js'\nimport {\n  HttpRequestError,\n  type HttpRequestErrorType,\n} from '../errors/request.js'\nimport type { Chain } from '../types/chain.js'\nimport type { Hex } from '../types/misc.js'\n\nimport type { Client } from '../clients/createClient.js'\nimport type { ErrorType } from '../errors/utils.js'\nimport { decodeErrorResult } from './abi/decodeErrorResult.js'\nimport { encodeAbiParameters } from './abi/encodeAbiParameters.js'\nimport { isAddressEqual } from './address/isAddressEqual.js'\nimport { concat } from './data/concat.js'\nimport { isHex } from './data/isHex.js'\nimport { stringify } from './stringify.js'\n\nexport const offchainLookupSignature = '0x556f1830'\nexport const offchainLookupAbiItem = {\n  name: 'OffchainLookup',\n  type: 'error',\n  inputs: [\n    {\n      name: 'sender',\n      type: 'address',\n    },\n    {\n      name: 'urls',\n      type: 'string[]',\n    },\n    {\n      name: 'callData',\n      type: 'bytes',\n    },\n    {\n      name: 'callbackFunction',\n      type: 'bytes4',\n    },\n    {\n      name: 'extraData',\n      type: 'bytes',\n    },\n  ],\n} as const satisfies Abi[number]\n\nexport type OffchainLookupErrorType = OffchainLookupErrorType_ | ErrorType\n\nexport async function offchainLookup<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  {\n    blockNumber,\n    blockTag,\n    data,\n    to,\n  }: Pick<CallParameters, 'blockNumber' | 'blockTag'> & {\n    data: Hex\n    to: Address\n  },\n): Promise<Hex> {\n  const { args } = decodeErrorResult({\n    data,\n    abi: [offchainLookupAbiItem],\n  })\n  const [sender, urls, callData, callbackSelector, extraData] = args\n\n  const { ccipRead } = client\n  const ccipRequest_ =\n    ccipRead && typeof ccipRead?.request === 'function'\n      ? ccipRead.request\n      : ccipRequest\n\n  try {\n    if (!isAddressEqual(to, sender))\n      throw new OffchainLookupSenderMismatchError({ sender, to })\n\n    const result = await ccipRequest_({ data: callData, sender, urls })\n\n    const { data: data_ } = await call(client, {\n      blockNumber,\n      blockTag,\n      data: concat([\n        callbackSelector,\n        encodeAbiParameters(\n          [{ type: 'bytes' }, { type: 'bytes' }],\n          [result, extraData],\n        ),\n      ]),\n      to,\n    } as CallParameters)\n\n    return data_!\n  } catch (err) {\n    throw new OffchainLookupError({\n      callbackSelector,\n      cause: err as BaseError,\n      data,\n      extraData,\n      sender,\n      urls,\n    })\n  }\n}\n\nexport type CcipRequestParameters = {\n  data: Hex\n  sender: Address\n  urls: readonly string[]\n}\n\nexport type CcipRequestReturnType = Hex\n\nexport type CcipRequestErrorType =\n  | HttpRequestErrorType\n  | OffchainLookupResponseMalformedErrorType\n  | ErrorType\n\nexport async function ccipRequest({\n  data,\n  sender,\n  urls,\n}: CcipRequestParameters): Promise<CcipRequestReturnType> {\n  let error = new Error('An unknown error occurred.')\n\n  for (let i = 0; i < urls.length; i++) {\n    const url = urls[i]\n    const method = url.includes('{data}') ? 'GET' : 'POST'\n    const body = method === 'POST' ? { data, sender } : undefined\n    const headers: HeadersInit =\n      method === 'POST' ? { 'Content-Type': 'application/json' } : {}\n\n    try {\n      const response = await fetch(\n        url.replace('{sender}', sender).replace('{data}', data),\n        {\n          body: JSON.stringify(body),\n          headers,\n          method,\n        },\n      )\n\n      let result: any\n      if (\n        response.headers.get('Content-Type')?.startsWith('application/json')\n      ) {\n        result = (await response.json()).data\n      } else {\n        result = (await response.text()) as any\n      }\n\n      if (!response.ok) {\n        error = new HttpRequestError({\n          body,\n          details: result?.error\n            ? stringify(result.error)\n            : response.statusText,\n          headers: response.headers,\n          status: response.status,\n          url,\n        })\n        continue\n      }\n\n      if (!isHex(result)) {\n        error = new OffchainLookupResponseMalformedError({\n          result,\n          url,\n        })\n        continue\n      }\n\n      return result\n    } catch (err) {\n      error = new HttpRequestError({\n        body,\n        details: (err as Error).message,\n        url,\n      })\n    }\n  }\n\n  throw error\n}\n"],"names":["OffchainLookupError","_BaseError","_inherits","_super","_createSuper","_ref","_cause$metaMessages","callbackSelector","cause","data","extraData","sender","urls","_classCallCheck","call","shortMessage","metaMessages","concat","_toConsumableArray","length","map","url","getUrl","flat","name","_createClass","BaseError","OffchainLookupResponseMalformedError","_BaseError2","_super2","_ref2","result","stringify","OffchainLookupSenderMismatchError","_BaseError3","_super3","_ref3","to","isAddressEqual","a","b","isAddress","strict","InvalidAddressError","address","toLowerCase","offchainLookupSignature","offchainLookupAbiItem","type","inputs","offchainLookup","_x","_x2","_offchainLookup","apply","arguments","_asyncToGenerator","_regeneratorRuntime","mark","_callee","client","blockNumber","blockTag","_decodeErrorResult","args","_args","callData","ccipRead","ccipRequest_","_yield$call","data_","wrap","_context","prev","next","decodeErrorResult","abi","_slicedToArray","request","ccipRequest","sent","encodeAbiParameters","abrupt","t0","stop","_x3","_ccipRequest","_callee2","error","i","method","body","headers","_response$headers$get","response","_result","_context2","Error","includes","undefined","fetch","replace","JSON","get","startsWith","json","text","ok","HttpRequestError","details","statusText","status","isHex","message"],"sourceRoot":""}